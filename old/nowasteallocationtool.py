# -*- coding: utf-8 -*-
"""NoWasteAllocationTool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AtO1N4aZiIod_IOQJMVcBYSZI1_0bhZ7
"""

# --- 1. Install Libraries ---
#pip install pulp pandas ipywidgets

# --- 2. Import Libraries ---
import pulp
import pandas as pd
import ipywidgets as widgets
from ipywidgets import interact, interactive, fixed, interact_manual
from IPython.display import display, HTML
import datetime as dt
from datetime import timedelta
import matplotlib.pyplot as plt

"""# Data definition :
At first we use mockup data.
Then we will use data connected to BigQuery in our CDS tables.
"""

# --- 3. Define Data (Expanded Mockup) ---
# --- Product Master Data Table (Unchanged) ---
product_master_data = {
    1: {"item_id": 1, "brand": "Lancome", "axe": "Skincare", "division": "Luxe", "donation_eligible": False},
    2: {"item_id": 2, "brand": "Maybelline", "axe": "Makeup", "division": "Consumer Products", "donation_eligible": True},
    3: {"item_id": 3, "brand": "Garnier", "axe": "Skincare", "division": "Consumer Products", "donation_eligible": True},
    4: {"item_id": 4, "brand": "La Roche Posay", "axe": "Skincare", "division": "LDB", "donation_eligible": True},
}
product_master_df = pd.DataFrame(product_master_data).T

# --- Second Life Channel Data Table (Increased Capacity) ---
second_life_channels = {
    1: {"channel_id": 1, "channel_type": "outlet", "country": "France", "capacity": 300, "min_coverage": 2}, # Reduced min_coverage
    2: {"channel_id": 2, "channel_type": "donation", "country": "France", "capacity": 500, "min_coverage": 1},
}
second_life_channels_df = pd.DataFrame(second_life_channels).T

# --- Bad Stock Inventory Table (Corrected Expiry Dates) ---
bad_stock_inventory = {
    1: {"item_id": 1, "ean": "1234567890123", "stock_quantity": 60*2, "expiry_date": (dt.datetime.now() + timedelta(days=120)).strftime('%Y-%m-%d')},
    2: {"item_id": 2, "ean": "9876543210123", "stock_quantity": 80*2, "expiry_date": (dt.datetime.now() + timedelta(days=150)).strftime('%Y-%m-%d')},
    3: {"item_id": 3, "ean": "5632104921933", "stock_quantity": 100*2, "expiry_date": (dt.datetime.now() + timedelta(days=180)).strftime('%Y-%m-%d')},
    4: {"item_id": 4, "ean": "1093218419823", "stock_quantity": 120*2, "expiry_date": (dt.datetime.now() + timedelta(days=210)).strftime('%Y-%m-%d')},
    }
bad_stock_inventory_df = pd.DataFrame(bad_stock_inventory).T


# --- Historical Sales Data Table (Adjusted for Realistic Demand) ---
historical_sales_data = {
    1: {"channel_id": 1, "item_id": 1, "date": "2023-12-01", "quantity_sold": 10}, # Reduced demand
    2: {"channel_id": 1, "item_id": 1, "date": "2023-12-08", "quantity_sold": 12}, # Reduced demand
    3: {"channel_id": 1, "item_id": 2, "date": "2023-12-01", "quantity_sold": 8},
    4: {"channel_id": 2, "item_id": 2, "date": "2023-12-05", "quantity_sold": 10},
    5: {"channel_id": 2, "item_id": 3, "date": "2023-12-08", "quantity_sold": 15},
    6: {"channel_id": 3, "item_id": 2, "date": "2023-12-02", "quantity_sold": 10},
    7: {"channel_id": 3, "item_id": 3, "date": "2023-12-10", "quantity_sold": 15},
    8: {"channel_id": 4, "item_id": 1, "date": "2023-12-06", "quantity_sold": 6},
    9: {"channel_id": 5, "item_id": 4, "date": "2023-12-09", "quantity_sold": 8},
    # ... add even more historical data for more realistic results
}
historical_sales_data_df = pd.DataFrame(historical_sales_data).T

# --- Demand and Revenue Data ---
# It's best to calculate these dynamically within your MIP function
# to handle different time ranges, but here's a simplified example:

# Example using dictionaries - these would be inputs to your MIP
import random
demand = {}
for product_id in range(1, 5):  # Products 1 to 4
    for channel_id in range(1, 3): # Channels 1 to 2
        demand[(product_id, channel_id)] = random.randint(0, 3) # Random demand between 5 and 25

revenue = {}
for product_id in range(1, 5):  # Products 1 to 4
    for channel_id in range(1, 3): # Channels 1 to 2
        revenue[(product_id, channel_id)] = round(random.uniform(5.0, 25.0), 2)  # Random revenue between 5.0 and 25.0

"""This Mixed Integer Programming (MIP) model seeks to determine the optimal allocation of bad stock quantities ($X_{pc}$) for each product ($p$) to each available second-life channel ($c$) while maximizing total revenue and adhering to supply, channel capacity, stock coverage targets, donation eligibility rules, and expiry date limitations.

**Sets :**

* $P$: & Set of all products (indexed by $p$) \\ % Line break and alignment with &
* $C$: & Set of all second life channels (indexed by $c$)



**Parameters :**


* $QS_p$: Quantity of bad stock available for product $p$  \\
* $Cap_c$: Capacity of channel $c$ \\
* $Rev_{pc}$: Expected revenue from selling product $p$ through channel $c$  \\
* $Cov_c$: Minimum stock coverage target for channel $c$ (in weeks or months) \\
* $DonEligible_{pc}$: 1 if product $p$ is eligible for donation through channel $c$, 0 otherwise \\
* $Exp_p$: Expiry date of product $p$ \\
* $CurrentDate$: Current date (for comparison)


**Decision variables**

* $X_{pc}$: Quantity of product $p$ allocated to channel $c$


**Objective Function (Maximize Revenue):**

\begin{equation*}
\text{Maximize: }  \sum_{p \in P} \sum_{c \in C} (Rev_{pc} * X_{pc})
\end{equation*}



1. Supply Constraint:
\begin{equation*}
\sum_{c \in C} X_{pc} \leq QS_p ,  \forall p \in P
\end{equation*}

2. Capacity Constraint:
\begin{equation*}
\sum_{p \in P} X_{pc} \leq Cap_c , \forall c \in C
\end{equation*}

3. Minimum Stock Coverage: (Assuming $Dem_{pc}$ represents estimated demand for product $p$ in channel $c$)
\begin{equation*}
\sum_{p \in P} (X_{pc} / Dem_{pc}) \geq Cov_c , \forall c \in C
\end{equation*}

4. Donation Eligibility:
\begin{equation*}
X_{pc} \leq DonEligible_{pc} * M , \forall p \in P, \forall c \in C
\end{equation*}
(where $M$ is a very large number)

5. Expiry Date Limit (for Outlet Channels):
\begin{equation*}
X_{pc} \leq \mathbb{1}  \{ (Exp_p - CurrentDate) > 3 \text{ months} \} * M , \forall p \in P, \forall c \in C_{\text{outlet}}
\end{equation*}
(where $\mathbb{1}\{\cdot\}$ is the indicator function, and  $C_{\text{outlet}}$ represents the set of outlet channels)



"""

# --- 4. MIP Model Function ---
def optimize_allocation(products_df, channels_df, bad_stock_df, demand, revenue):
    """Solves the MIP and returns allocation results."""

    # 1. Create MIP Problem
    model = pulp.LpProblem("No_Waste_Allocation", pulp.LpMaximize)

    # 2. Decision Variables
    allocation = {}
    for p in products_df["item_id"].unique(): # Iterate over unique item_ids
        for c in channels_df["channel_id"].unique(): # Iterate over unique channel_ids
            allocation[(p, c)] = pulp.LpVariable(f"X_{p}_{c}", lowBound=0, cat='Integer')

    # Create is_allocated_p variables
    is_allocated = {}
    for p in products_df["item_id"].unique():
        is_allocated[p] = pulp.LpVariable(f"is_allocated_{p}", cat='Binary')

    # 3. Objective Function: Maximize Total Revenue
    model += pulp.lpSum([revenue.get((p, c), 0) * allocation[(p, c)] for p in products_df["item_id"].unique() for c in channels_df["channel_id"].unique()]) + \
              1000 * pulp.lpSum([is_allocated[p] for p in products_df["item_id"].unique()]), "Total_Value"


    # 4. Constraints
    # 4.1 Supply Constraint: Allocation cannot exceed available bad stock
    for index, row in bad_stock_df.iterrows():
        model += pulp.lpSum([allocation.get((row['item_id'], c), 0) for c in channels_df["channel_id"].unique()]) <= row['stock_quantity'], f"Supply_{row['item_id']}"

    # 4.2 Capacity Constraint: Allocation cannot exceed channel capacity
    for index, row in channels_df.iterrows():
        model += pulp.lpSum([allocation.get((p, row['channel_id']), 0) for p in products_df["item_id"].unique()]) <= row['capacity'], f"Capacity_{row['channel_id']}"

    # 4.3 Minimum Stock Coverage Constraint (Corrected)
    for c in channels_df["channel_id"].unique():
        for p in products_df['item_id'].unique():
            # If demand is zero, no need to send any stock
            if demand.get((p, c), 0) == 0:
                model += allocation[(p,c)] == 0, f'No_Demand_Prod_{p}_Channel_{c}'
            elif demand.get((p, c), 0) > 0:  # <-- Corrected condition!
                # Apply constraint only when demand is greater than zero
                model += allocation.get((p, c), 0) >= (channels_df[channels_df["channel_id"]==c]["min_coverage"].values[0] * demand.get((p, c), 1e-5)), f"Min_Coverage_{p}_{c}"


    # 4.4 Donation Eligibility (Corrected)
    #for p_index, p_row in products_df.iterrows():
     #   for c_index, c_row in channels_df.iterrows():
      #    if c_row["channel_type"] == "outlet" and p_row["brand"] == "Lancome":
       #     # Lanc√¥me products cannot go to outlets
        #    model += allocation[(p_row["item_id"], c_row["channel_id"])] == 0, f"No_Lancome_Outlet_{p_row['item_id']}_{c_row['channel_id']}"
         # elif c_row["channel_type"] == "donation" and not p_row["donation_eligible"]:
          #  # Non-donation-eligible products cannot go to donation centers
           # model += allocation[(p_row["item_id"], c_row["channel_id"])] == 0, f"Not_Donation_Eligible_{p_row['item_id']}_{c_row['channel_id']}"

        # All other combinations are allowed (no additional constraint needed)

   # 4.5 Expiry Date Constraint (Assume 3-month rule for outlets)
    today = dt.date(dt.datetime.now().year, dt.datetime.now().month, dt.datetime.now().day)
    for index, row in bad_stock_df.iterrows():
      expiry_date = dt.datetime.strptime(row["expiry_date"], "%Y-%m-%d").date()  # Get date portion
      if (expiry_date - today).days < 90: # Approx. 3 months
        for c_index, c_row in channels_df.iterrows():
          if c_row["channel_type"] == "outlet":
            model += allocation[(row["item_id"], c_row["channel_id"])] == 0, f"Expiry_Outlet_{row['item_id']}_{c_row['channel_id']}"

    #4.6 Definition of is_allocated variable in terms of allocation for a given product in channels
    for p in products_df["item_id"].unique():
         model += pulp.lpSum([allocation[(p, c)] for c in channels_df["channel_id"].unique()]) <= 1e6 * is_allocated[p], f"Allocation_Indicator_{p}"

    # 5. Solve the Model
    model.solve()
    print("Status:", pulp.LpStatus[model.status])

    # 6. Process Results (Enhanced)
    results = []
    for (p, c) in allocation:
        if allocation[(p, c)].varValue > 0:
            results.append({
                "Product ID": p,
                "Product Name": products_df[products_df["item_id"]==p]["brand"].values[0],
                "Product Axe": products_df[products_df["item_id"]==p]["axe"].values[0],
                "Expiry Date": bad_stock_inventory_df[bad_stock_inventory_df["item_id"]==p]["expiry_date"].values[0],
                "Channel ID": c,
                "Channel Type": channels_df[channels_df["channel_id"]==c]["channel_type"].values[0],
                "Country" : channels_df[channels_df["channel_id"]==c]["country"].values[0],
                "Channel Capacity": channels_df[channels_df["channel_id"]==c]["capacity"].values[0], # Add capacity
                "Min Coverage": channels_df[channels_df["channel_id"]==c]["min_coverage"].values[0], # Add min_coverage
                "Quantity Allocated": allocation[(p, c)].varValue,
                "Demand": demand.get((p, c), 0),
                "Revenue per Unit": revenue.get((p, c), 0.0),
                "Total Revenue": revenue.get((p, c), 0.0) * allocation[(p, c)].varValue
            })
    results_df = pd.DataFrame(results)

    # Add Objective Function Value to DataFrame
    results_df.loc['Total', 'Total Revenue'] = model.objective.value()

    # Make DataFrame Scrollable in Colab
    display(HTML(results_df.to_html()))

    return results_df

print(bad_stock_inventory_df)
print("")
print("")
print("")

print(second_life_channels_df)
print("")
print("")
print("")

print(product_master_df)
print("")
print("")
print("")

print(historical_sales_data_df)
print("")
print("")
print("")

print(demand)
print("")
print("")
print("")

print(revenue)

# --- Call the MIP function and display results (outside the function) ---
results_df = optimize_allocation(product_master_df, second_life_channels_df, bad_stock_inventory_df, demand, revenue)
print("Allocation Results:")
print(results_df)

"""# UI : Visualize the allocation"""

# --- 5. Interactive Visualization ---
@interact(
    country=widgets.Dropdown(options=second_life_channels_df['country'].unique(), description='Country:'),
    channel_type=widgets.Dropdown(options=second_life_channels_df['channel_type'].unique(), description='Channel Type:')
)
def display_allocation(country=None, channel_type=None):
    """Displays filtered allocation results."""
    # Filter Channels DataFrame
    filtered_channels_df = second_life_channels_df.copy()
    if country:
        filtered_channels_df = filtered_channels_df[filtered_channels_df['country'] == country]
    if channel_type:
        filtered_channels_df = filtered_channels_df[filtered_channels_df['channel_type'] == channel_type]

    # --- Display Input DataFrames ---
    print("## Input Data:")
    display(HTML(product_master_df.to_html()))
    display(HTML(filtered_channels_df.to_html())) # Use filtered DataFrame
    display(HTML(bad_stock_inventory_df.to_html()))
    display(HTML(pd.DataFrame(demand, index=["Demand"]).T.to_html()))  # Convert demand dictionary to DataFrame
    display(HTML(pd.DataFrame(revenue, index=["Revenue"]).T.to_html())) # Convert revenue dictionary to DataFrame


    # --- Display Allocation Results ---
    print("## Allocation Results:")
    display(HTML(results_df.to_html()))

    # --- Create a Bar Chart Visualization ---
    plt.figure(figsize=(10, 6))
    for p in results_df["Product Name"].unique():
        product_data = results_df[results_df["Product Name"] == p]
        plt.bar(product_data["Channel Type"], product_data["Quantity Allocated"], label=p)

    plt.xlabel("Channel Type")
    plt.ylabel("Quantity Allocated")
    plt.title("Product Allocation by Channel Type")
    plt.legend()
    plt.xticks(rotation=45, ha="right")  # Rotate x-axis labels for better readability